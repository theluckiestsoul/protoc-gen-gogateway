package generator

import (
	"fmt"
	"net/http"

	"github.com/theluckiestsoul/protoc-gen-gogateway/internal/models"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	GENERATOR_EDIT_WARNING = "// Code generated by Go Gateway. DO NOT EDIT."
)

var (
	repositoryContractPath = "%s/internal/repository/contract"
	usecaseContractPath    = "%s/internal/usecase/contract"
	repositoryImplPath     = "%s/internal/repository/implementation"
	usecaseImplPath        = "%s/internal/usecase/implementation"
	handlerPath            = "%s/internal/handler"
	adapterPath            = "%s/internal/adapter"
	serverPath             = "%s/internal/adapter/server"
	fakerPath              = "github.com/go-faker/faker/v4"
	mockRepoPath           = "%s/internal/repository/mock"
	echov4Path             = "github.com/labstack/echo/v4"
	mapperPath             = "%s/internal/mapper"
	iampath                = "%s/internal/iam"
	configPath             = "%s/internal/config"
	typesPath              = "%s/internal/types"
)

func formatImportPath(mod *string) {
	repositoryContractPath = fmt.Sprintf(repositoryContractPath, *mod)
	usecaseContractPath = fmt.Sprintf(usecaseContractPath, *mod)
	repositoryImplPath = fmt.Sprintf(repositoryImplPath, *mod)
	usecaseImplPath = fmt.Sprintf(usecaseImplPath, *mod)
	handlerPath = fmt.Sprintf(handlerPath, *mod)
	adapterPath = fmt.Sprintf(adapterPath, *mod)
	mockRepoPath = fmt.Sprintf(mockRepoPath, *mod)
	serverPath = fmt.Sprintf(serverPath, *mod)
	mapperPath = fmt.Sprintf(mapperPath, *mod)
	iampath = fmt.Sprintf(iampath, *mod)
	configPath = fmt.Sprintf(configPath, *mod)
	typesPath = fmt.Sprintf(typesPath, *mod)
}

type Generator struct {
	mod  *string
	port *string
}

func NewGenerator(mod *string, port *string) *Generator {
	formatImportPath(mod)
	return &Generator{
		mod:  mod,
		port: port,
	}
}

func (gr *Generator) GenerateFiles(gen *protogen.Plugin, file *models.FileInfo) *protogen.GeneratedFile {
	gr.genRepositoryInterface(gen, file)
	gr.genRepositoryImplementation(gen, file)
	gr.genMockRepository(gen, file)
	gr.genUseCaseInterface(gen, file)
	gr.genUseCaseImplementation(gen, file)
	gr.generateHandlers(gen, file)
	gr.generateAdapters(gen, file)
	return nil
}

func (gr *Generator) GenerateServer(gen *protogen.Plugin, file *models.FileInfo) *protogen.GeneratedFile {
	gr.generateMain(gen, file)
	gr.generateServer(gen, file)
	gr.generateMapper(gen, file)
	return nil
}

func (gr *Generator) getHttpOption(method *protogen.Method) *models.HttpOption {
	options, ok := method.Desc.Options().(*descriptorpb.MethodOptions)
	if !ok {
		return nil
	}

	httpRule, ok := proto.GetExtension(options, annotations.E_Http).(*annotations.HttpRule)
	if !ok {
		return nil
	}

	var (
		httpMethod string
		path       string
	)

	switch httpRule.GetPattern().(type) {
	case *annotations.HttpRule_Get:
		httpMethod = http.MethodGet
		path = httpRule.GetGet()
	case *annotations.HttpRule_Put:
		httpMethod = http.MethodPut
		path = httpRule.GetPut()
	case *annotations.HttpRule_Post:
		httpMethod = http.MethodPost
		path = httpRule.GetPost()
	case *annotations.HttpRule_Delete:
		httpMethod = http.MethodDelete
		path = httpRule.GetDelete()
	case *annotations.HttpRule_Patch:
		httpMethod = http.MethodPatch
		path = httpRule.GetPatch()
	}
	op := &models.HttpOption{
		Method: httpMethod,
		Path:   path,
	}
	return op
}

func (gr *Generator) hasAnyHttpOption(s *protogen.Service) bool {
	for _, m := range s.Methods {
		option := gr.getHttpOption(m)
		if option.Method != "" && option.Path != "" {
			return true
		}
	}
	return false
}

func (gr *Generator) isMapperRequired(s *protogen.Service) bool {
	for _, m := range s.Methods {
		option := gr.getHttpOption(m)
		if option.Method != "" && option.Path != "" && option.Method != "POST" {
			return true
		}
	}
	return false
}
