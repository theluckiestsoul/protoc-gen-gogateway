package generator

import (
	"strconv"

	"github.com/theluckiestsoul/protoc-gen-gogateway/internal/models"
	"google.golang.org/protobuf/compiler/protogen"
)

func (gr *Generator) generateMapper(gen *protogen.Plugin, f *models.FileInfo) {
	filename := "mapper/mapper.go"

	g := gen.NewGeneratedFile(string(filename), "mapper")
	g.P(GENERATOR_EDIT_WARNING)
	g.P("package mapper")
	g.P()
	g.P("import (")
	g.P(strconv.Quote("fmt"))
	g.P(strconv.Quote("reflect"))
	g.P(strconv.Quote("strconv"))
	g.P(strconv.Quote("strings"))
	g.P(strconv.Quote("errors"))
	g.P(")")
	g.P()
	g.P()
	g.P("func AggregatePathParams(params []string, values []string) map[string][]string {")
	g.P("m := make(map[string][]string)")
	g.P("for i, v := range params {")
	g.P("m[v] = []string{values[i]}")
	g.P("}")
	g.P("return m")
	g.P("}")
	g.P()
	g.P()

	g.P("func MapParams[T any](params map[string][]string, out T, enums map[string]map[string]int64) error {")
	g.P("if reflect.TypeOf(out).Kind() != reflect.Ptr {")
	g.P("return fmt.Errorf(\"out must be a pointer\")")
	g.P("}")
	g.P("v := reflect.ValueOf(out).Elem()")
	g.P("for i := 0; i < v.NumField(); i++ {")
	g.P("field := v.Field(i)")
	g.P("tags := v.Type().Field(i).Tag.Get(\"protobuf\")")
	g.P("pbTags := extractFromTag(tags)")
	g.P("if len(pbTags) == 0 {")
	g.P("continue")
	g.P("}")
	g.P("var fieldName string")
	g.P("if jsonTag, ok := pbTags[\"json\"]; ok {")
	g.P("fieldName = jsonTag")
	g.P("} else {")
	g.P("fieldName = pbTags[\"name\"]")
	g.P("}")
	g.P("fieldValue, ok := params[fieldName]")
	g.P("if !ok && field.Kind() != reflect.Ptr {")
	g.P("continue")
	g.P("}else if !ok && field.Kind() == reflect.Ptr {")
	g.P("if field.IsNil() {")
	g.P("field.Set(reflect.New(field.Type().Elem()))")
	g.P("}")
	g.P("fieldType := field.Type().Elem()")
	g.P("typeName := fieldType.Name()")
	g.P("// Remove \"*\" and \"[]\" prefixes from the type name.")
	g.P("typeName = strings.TrimPrefix(typeName, \"*\")")
	g.P("typeName = strings.TrimPrefix(typeName, \"[]\")")
	g.P("// Split the type name into parts using \".\" as the separator.")
	g.P("typeParts := strings.Split(typeName, \".\")")
	g.P("// If there is more than one part, use the second part as the type name.")
	g.P("// Otherwise, use the only part as the type name.")
	g.P("if len(typeParts) > 1 {")
	g.P("typeName = typeParts[1]")
	g.P("} else if len(typeParts) == 1 {")
	g.P("typeName = typeParts[0]")
	g.P("}")
	g.P("embeddedMap := make(map[string][]string)")
	g.P("for k, v := range params {")
	g.P("typeNameLower := strings.ToLower(typeName)")
	g.P("keyLower := strings.ToLower(k)")
	g.P("if strings.HasPrefix(keyLower, typeNameLower+\".\") {")
	g.P("//extract the substring after the type name.")
	g.P("//e.g. if the type name is \"User\" and the key is \"User.name\", then the substring is \"name\".")
	g.P("embeddedPropName := k[len(typeName)+1:]")
	g.P("embeddedMap[embeddedPropName] = v")
	g.P("}")
	g.P("}")
	g.P("err := MapParams(embeddedMap, field.Interface(), enums)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("continue")
	g.P("}")
	g.P("if enum, ok := pbTags[\"enum\"]; ok {")
	g.P("if field.Kind() == reflect.Slice {")
	g.P("slice := reflect.MakeSlice(field.Type(), len(fieldValue), len(fieldValue))")
	g.P("for i, v := range fieldValue {")
	g.P("if enumValue, ok := enums[enum][v]; ok {")
	g.P("//append to slice")
	g.P("slice.Index(i).SetInt(enumValue)")
	g.P("} else {")
	g.P("return fmt.Errorf(\"invalid enum value: %s\", v)")
	g.P("}")
	g.P("}")
	g.P("//assign array to field")
	g.P("field.Set(slice)")
	g.P("continue")
	g.P("}")
	g.P("if enumValue, ok := enums[enum][fieldValue[0]]; ok {")
	g.P("field.SetInt(enumValue)")
	g.P("continue")
	g.P("}")
	g.P("return fmt.Errorf(\"invalid enum value: %s\", fieldValue[0])")
	g.P("}")
	g.P("kind := field.Kind()")
	g.P("switch kind {")
	g.P("case reflect.String:")
	g.P("field.SetString(fieldValue[0])")
	g.P("case reflect.Int64:")
	g.P("num, err := strconv.ParseInt(fieldValue[0], 10, 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetInt(num)")
	g.P("case reflect.Int32:")
	g.P("num, err := strconv.ParseInt(fieldValue[0], 10, 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetInt(num)")
	g.P("case reflect.Int:")
	g.P("num, err := strconv.ParseInt(fieldValue[0], 10, 0)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetInt(num)")
	g.P("case reflect.Float64:")
	g.P("num, err := strconv.ParseFloat(fieldValue[0], 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetFloat(num)")
	g.P("case reflect.Float32:")
	g.P("num, err := strconv.ParseFloat(fieldValue[0], 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetFloat(num)")
	g.P("case reflect.Uint64:")
	g.P("num, err := strconv.ParseUint(fieldValue[0], 10, 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetUint(num)")
	g.P("case reflect.Uint32:")
	g.P("num, err := strconv.ParseUint(fieldValue[0], 10, 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetUint(num)")
	g.P("case reflect.Uint:")
	g.P("num, err := strconv.ParseUint(fieldValue[0], 10, 0)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetUint(num)")
	g.P("case reflect.Bool:")
	g.P("num, err := strconv.ParseBool(fieldValue[0])")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("field.SetBool(num)")
	g.P("case reflect.Slice:")
	g.P("if field.Type().Elem().Kind() == reflect.String {")
	g.P("field.Set(reflect.ValueOf(fieldValue))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Int64 {")
	g.P("var int64Slice []int64")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseInt(v, 10, 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("int64Slice = append(int64Slice, num)")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(int64Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Int32 {")
	g.P("var int32Slice []int32")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseInt(v, 10, 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("int32Slice = append(int32Slice, int32(num))")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(int32Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Int {")
	g.P("var intSlice []int")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseInt(v, 10, 0)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("intSlice = append(intSlice, int(num))")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(intSlice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Float64 {")
	g.P("var float64Slice []float64")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseFloat(v, 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("float64Slice = append(float64Slice, num)")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(float64Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Float32 {")
	g.P("var float32Slice []float32")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseFloat(v, 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("float32Slice = append(float32Slice, float32(num))")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(float32Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Uint64 {")
	g.P("var uint64Slice []uint64")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseUint(v, 10, 64)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("uint64Slice = append(uint64Slice, num)")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(uint64Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Uint32 {")
	g.P("var uint32Slice []uint32")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseUint(v, 10, 32)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("uint32Slice = append(uint32Slice, uint32(num))")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(uint32Slice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Uint {")
	g.P("var uintSlice []uint")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseUint(v, 10, 0)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("uintSlice = append(uintSlice, uint(num))")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(uintSlice))")
	g.P("} else if field.Type().Elem().Kind() == reflect.Bool {")
	g.P("var boolSlice []bool")
	g.P("for _, v := range fieldValue {")
	g.P("num, err := strconv.ParseBool(v)")
	g.P("if err != nil {")
	g.P("return err")
	g.P("}")
	g.P("boolSlice = append(boolSlice, num)")
	g.P("}")
	g.P("field.Set(reflect.ValueOf(boolSlice))")
	g.P("} else {")
	g.P("return errors.New(\"unsupport slice type\")")
	g.P("}")
	g.P("}")
	g.P("}")
	g.P("return nil")
	g.P("}")
	g.P()
	g.P()

	g.P("func extractFromTag(tag string) map[string]string {")
	g.P("mp := make(map[string]string)")
	g.P("parts := strings.Split(tag, \",\")")
	g.P("if len(parts) == 0 {")
	g.P("return mp")
	g.P("}")
	g.P("for _, part := range parts {")
	g.P("kv := strings.Split(part, \"=\")")
	g.P("if len(kv) == 2 {")
	g.P("mp[kv[0]] = kv[1]")
	g.P("}")
	g.P("}")
	g.P("return mp")
	g.P("}")
}
