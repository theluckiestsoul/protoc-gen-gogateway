// Code generated by Go Gateway. DO NOT EDIT.
package mapper

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"errors"
)

func AggregatePathParams(params []string, values []string) map[string][]string {
	m := make(map[string][]string)
	for i, v := range params {
		m[v] = []string{values[i]}
	}
	return m
}

func MapParams[T any](params map[string][]string, out T, enums map[string]map[string]int64) error {
	if reflect.TypeOf(out).Kind() != reflect.Ptr {
		return fmt.Errorf("out must be a pointer")
	}
	v := reflect.ValueOf(out).Elem()
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		tags := v.Type().Field(i).Tag.Get("protobuf")
		pbTags := extractFromTag(tags)
		if len(pbTags) == 0 {
			continue
		}
		var fieldName string
		if jsonTag, ok := pbTags["json"]; ok {
			fieldName = jsonTag
		} else {
			fieldName = pbTags["name"]
		}
		fieldValue, ok := params[fieldName]
		if !ok && field.Kind() != reflect.Ptr {
			continue
		} else if !ok && field.Kind() == reflect.Ptr {
			if field.IsNil() {
				field.Set(reflect.New(field.Type().Elem()))
			}
			fieldType := field.Type().Elem()
			typeName := fieldType.Name()
			// Remove "*" and "[]" prefixes from the type name.
			typeName = strings.TrimPrefix(typeName, "*")
			typeName = strings.TrimPrefix(typeName, "[]")
			// Split the type name into parts using "." as the separator.
			typeParts := strings.Split(typeName, ".")
			// If there is more than one part, use the second part as the type name.
			// Otherwise, use the only part as the type name.
			if len(typeParts) > 1 {
				typeName = typeParts[1]
			} else if len(typeParts) == 1 {
				typeName = typeParts[0]
			}
			embeddedMap := make(map[string][]string)
			for k, v := range params {
				typeNameLower := strings.ToLower(typeName)
				keyLower := strings.ToLower(k)
				if strings.HasPrefix(keyLower, typeNameLower+".") {
					// extract the substring after the type name.
					// e.g. if the type name is "User" and the key is "User.name", then the substring is "name".
					embeddedPropName := k[len(typeName)+1:]
					embeddedMap[embeddedPropName] = v
				}
			}
			err := MapParams(embeddedMap, field.Interface(), enums)
			if err != nil {
				return err
			}
			continue
		}
		if enum, ok := pbTags["enum"]; ok {
			if field.Kind() == reflect.Slice {
				slice := reflect.MakeSlice(field.Type(), len(fieldValue), len(fieldValue))
				for i, v := range fieldValue {
					if enumValue, ok := enums[enum][v]; ok {
						// append to slice
						slice.Index(i).SetInt(enumValue)
					} else {
						return fmt.Errorf("invalid enum value: %s", v)
					}
				}
				// assign array to field
				field.Set(slice)
				continue
			}
			if enumValue, ok := enums[enum][fieldValue[0]]; ok {
				field.SetInt(enumValue)
				continue
			}
			return fmt.Errorf("invalid enum value: %s", fieldValue[0])
		}
		kind := field.Kind()
		switch kind {
		case reflect.String:
			field.SetString(fieldValue[0])
		case reflect.Int64:
			num, err := strconv.ParseInt(fieldValue[0], 10, 64)
			if err != nil {
				return err
			}
			field.SetInt(num)
		case reflect.Int32:
			num, err := strconv.ParseInt(fieldValue[0], 10, 32)
			if err != nil {
				return err
			}
			field.SetInt(num)
		case reflect.Int:
			num, err := strconv.ParseInt(fieldValue[0], 10, 0)
			if err != nil {
				return err
			}
			field.SetInt(num)
		case reflect.Float64:
			num, err := strconv.ParseFloat(fieldValue[0], 64)
			if err != nil {
				return err
			}
			field.SetFloat(num)
		case reflect.Float32:
			num, err := strconv.ParseFloat(fieldValue[0], 32)
			if err != nil {
				return err
			}
			field.SetFloat(num)
		case reflect.Uint64:
			num, err := strconv.ParseUint(fieldValue[0], 10, 64)
			if err != nil {
				return err
			}
			field.SetUint(num)
		case reflect.Uint32:
			num, err := strconv.ParseUint(fieldValue[0], 10, 32)
			if err != nil {
				return err
			}
			field.SetUint(num)
		case reflect.Uint:
			num, err := strconv.ParseUint(fieldValue[0], 10, 0)
			if err != nil {
				return err
			}
			field.SetUint(num)
		case reflect.Bool:
			num, err := strconv.ParseBool(fieldValue[0])
			if err != nil {
				return err
			}
			field.SetBool(num)
		case reflect.Slice:
			if field.Type().Elem().Kind() == reflect.String {
				field.Set(reflect.ValueOf(fieldValue))
			} else if field.Type().Elem().Kind() == reflect.Int64 {
				var int64Slice []int64
				for _, v := range fieldValue {
					num, err := strconv.ParseInt(v, 10, 64)
					if err != nil {
						return err
					}
					int64Slice = append(int64Slice, num)
				}
				field.Set(reflect.ValueOf(int64Slice))
			} else if field.Type().Elem().Kind() == reflect.Int32 {
				var int32Slice []int32
				for _, v := range fieldValue {
					num, err := strconv.ParseInt(v, 10, 32)
					if err != nil {
						return err
					}
					int32Slice = append(int32Slice, int32(num))
				}
				field.Set(reflect.ValueOf(int32Slice))
			} else if field.Type().Elem().Kind() == reflect.Int {
				var intSlice []int
				for _, v := range fieldValue {
					num, err := strconv.ParseInt(v, 10, 0)
					if err != nil {
						return err
					}
					intSlice = append(intSlice, int(num))
				}
				field.Set(reflect.ValueOf(intSlice))
			} else if field.Type().Elem().Kind() == reflect.Float64 {
				var float64Slice []float64
				for _, v := range fieldValue {
					num, err := strconv.ParseFloat(v, 64)
					if err != nil {
						return err
					}
					float64Slice = append(float64Slice, num)
				}
				field.Set(reflect.ValueOf(float64Slice))
			} else if field.Type().Elem().Kind() == reflect.Float32 {
				var float32Slice []float32
				for _, v := range fieldValue {
					num, err := strconv.ParseFloat(v, 32)
					if err != nil {
						return err
					}
					float32Slice = append(float32Slice, float32(num))
				}
				field.Set(reflect.ValueOf(float32Slice))
			} else if field.Type().Elem().Kind() == reflect.Uint64 {
				var uint64Slice []uint64
				for _, v := range fieldValue {
					num, err := strconv.ParseUint(v, 10, 64)
					if err != nil {
						return err
					}
					uint64Slice = append(uint64Slice, num)
				}
				field.Set(reflect.ValueOf(uint64Slice))
			} else if field.Type().Elem().Kind() == reflect.Uint32 {
				var uint32Slice []uint32
				for _, v := range fieldValue {
					num, err := strconv.ParseUint(v, 10, 32)
					if err != nil {
						return err
					}
					uint32Slice = append(uint32Slice, uint32(num))
				}
				field.Set(reflect.ValueOf(uint32Slice))
			} else if field.Type().Elem().Kind() == reflect.Uint {
				var uintSlice []uint
				for _, v := range fieldValue {
					num, err := strconv.ParseUint(v, 10, 0)
					if err != nil {
						return err
					}
					uintSlice = append(uintSlice, uint(num))
				}
				field.Set(reflect.ValueOf(uintSlice))
			} else if field.Type().Elem().Kind() == reflect.Bool {
				var boolSlice []bool
				for _, v := range fieldValue {
					num, err := strconv.ParseBool(v)
					if err != nil {
						return err
					}
					boolSlice = append(boolSlice, num)
				}
				field.Set(reflect.ValueOf(boolSlice))
			} else {
				return errors.New("unsupport slice type")
			}
		}
	}
	return nil
}

func extractFromTag(tag string) map[string]string {
	mp := make(map[string]string)
	parts := strings.Split(tag, ",")
	if len(parts) == 0 {
		return mp
	}
	for _, part := range parts {
		kv := strings.Split(part, "=")
		if len(kv) == 2 {
			mp[kv[0]] = kv[1]
		}
	}
	return mp
}
